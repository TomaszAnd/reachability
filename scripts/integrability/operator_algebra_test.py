#!/usr/bin/env python3
"""
Test operator algebra hypothesis for criterion ordering flip.

HYPOTHESIS: The Lie algebra generated by operators affects controllability
and thus criterion ordering.

- Larger Lie algebra → more control → Spectral optimization works better
- Smaller Lie algebra → restricted control → Krylov (subspace) may be better

The dynamical Lie algebra g = Lie({H_1, ..., H_k}) determines what unitaries
U = exp(-iHt) can be realized.

TESTS:
1. Compute Lie algebra dimension for GEO2 vs Canonical operators
2. Correlate algebra dimension with criterion ordering

Usage:
    python scripts/integrability/operator_algebra_test.py

Author: Claude Code (research exploration)
Date: 2026-01-13
"""

import numpy as np
import qutip
from pathlib import Path
import pickle
from datetime import datetime
from typing import List, Dict, Tuple, Optional
import matplotlib.pyplot as plt
from scipy.linalg import svd

import sys
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from reach import models


# =============================================================================
# LIE ALGEBRA COMPUTATION
# =============================================================================

def commutator(A: np.ndarray, B: np.ndarray) -> np.ndarray:
    """Compute matrix commutator [A, B] = AB - BA."""
    return A @ B - B @ A


def matrix_to_vector(M: np.ndarray) -> np.ndarray:
    """Flatten matrix to vector (column-major order)."""
    return M.flatten('F')


def vector_to_matrix(v: np.ndarray, d: int) -> np.ndarray:
    """Reshape vector back to d×d matrix."""
    return v.reshape((d, d), order='F')


def is_linearly_independent(v: np.ndarray, basis_matrix: np.ndarray,
                             tol: float = 1e-10) -> bool:
    """
    Check if vector v is linearly independent of columns in basis_matrix.

    Args:
        v: New vector to test
        basis_matrix: Matrix with existing basis vectors as columns
        tol: Tolerance for rank determination

    Returns:
        True if v is linearly independent
    """
    if basis_matrix.shape[1] == 0:
        return np.linalg.norm(v) > tol

    # Augment basis with new vector
    augmented = np.column_stack([basis_matrix, v])

    # Compare ranks
    rank_old = np.linalg.matrix_rank(basis_matrix, tol=tol)
    rank_new = np.linalg.matrix_rank(augmented, tol=tol)

    return rank_new > rank_old


def compute_lie_algebra_dimension(
    operators: List[qutip.Qobj],
    max_depth: int = 6,
    max_dim: int = None,
    verbose: bool = False
) -> Dict:
    """
    Compute dimension of Lie algebra generated by operators.

    Uses iterative commutator expansion:
    g_0 = span{H_i}
    g_{k+1} = g_k + span{[A, B] : A ∈ g_k, B ∈ g_0}

    Args:
        operators: List of Hermitian operators (generators)
        max_depth: Maximum commutator depth
        max_dim: Maximum expected dimension (for early stopping)
        verbose: Print progress

    Returns:
        Dictionary with:
        - dimension: Final Lie algebra dimension
        - depth_reached: Commutator depth when saturation occurred
        - dims_by_depth: List of dimensions at each depth
        - is_saturated: Whether algebra saturated (no new generators)
    """
    if len(operators) == 0:
        return {"dimension": 0, "depth_reached": 0, "dims_by_depth": [0], "is_saturated": True}

    d = operators[0].shape[0]
    if max_dim is None:
        max_dim = d ** 2  # Maximum for u(d)

    # Convert to numpy arrays and make traceless (for su(d))
    mats = []
    for op in operators:
        M = op.full()
        # Make traceless: M' = M - Tr(M)/d * I
        M = M - np.trace(M) / d * np.eye(d)
        mats.append(M)

    # Initialize basis with original operators (as vectors)
    basis_vectors = []
    for M in mats:
        v = matrix_to_vector(M)
        if len(basis_vectors) == 0:
            if np.linalg.norm(v) > 1e-12:
                basis_vectors.append(v)
        else:
            basis_matrix = np.column_stack(basis_vectors)
            if is_linearly_independent(v, basis_matrix):
                basis_vectors.append(v)

    dims_by_depth = [len(basis_vectors)]

    if verbose:
        print(f"Depth 0: dim = {len(basis_vectors)}")

    # Iterative commutator expansion
    original_mats = mats.copy()
    current_mats = mats.copy()

    for depth in range(1, max_depth + 1):
        new_mats = []

        # Compute commutators [current, original]
        for A in current_mats:
            for B in original_mats:
                C = commutator(A, B)

                # Check if linearly independent
                v = matrix_to_vector(C)
                if np.linalg.norm(v) < 1e-12:
                    continue

                basis_matrix = np.column_stack(basis_vectors) if basis_vectors else np.zeros((d*d, 0))
                if is_linearly_independent(v, basis_matrix):
                    basis_vectors.append(v)
                    new_mats.append(C)

                    if len(basis_vectors) >= max_dim:
                        break
            if len(basis_vectors) >= max_dim:
                break

        dims_by_depth.append(len(basis_vectors))

        if verbose:
            print(f"Depth {depth}: dim = {len(basis_vectors)} (+{len(new_mats)} new)")

        # Check for saturation
        if len(new_mats) == 0 or len(basis_vectors) >= max_dim:
            return {
                "dimension": len(basis_vectors),
                "depth_reached": depth,
                "dims_by_depth": dims_by_depth,
                "is_saturated": len(new_mats) == 0 or len(basis_vectors) >= max_dim
            }

        current_mats = new_mats

    return {
        "dimension": len(basis_vectors),
        "depth_reached": max_depth,
        "dims_by_depth": dims_by_depth,
        "is_saturated": False
    }


# =============================================================================
# ENSEMBLE COMPARISON
# =============================================================================

def analyze_ensemble_algebras(d: int, k_values: List[int], n_samples: int = 10) -> Dict:
    """
    Compare Lie algebra dimensions for different ensembles.

    Args:
        d: Hilbert space dimension
        k_values: List of K values to test
        n_samples: Number of random samples per K

    Returns:
        Dictionary with algebra dimensions for each ensemble
    """
    results = {
        "d": d,
        "k_values": k_values,
        "canonical": {"dims": [], "sems": []},
        "gue": {"dims": [], "sems": []},
    }

    # Maximum algebra dimension is d²-1 for su(d)
    max_dim = d ** 2 - 1

    print(f"\n{'='*60}")
    print(f"Lie Algebra Analysis: d={d}, max_dim={max_dim}")
    print(f"{'='*60}")

    for k in k_values:
        print(f"\nK = {k}:")

        # Canonical ensemble
        can_dims = []
        for seed in range(n_samples):
            rng = np.random.RandomState(seed)
            try:
                # Sample from canonical basis
                canonical = models.CanonicalBasis(d)
                ops = canonical.sample_k_operators(k, rng)
                result = compute_lie_algebra_dimension(ops, max_depth=4, max_dim=max_dim)
                can_dims.append(result["dimension"])
            except Exception as e:
                pass

        if can_dims:
            results["canonical"]["dims"].append(np.mean(can_dims))
            results["canonical"]["sems"].append(np.std(can_dims) / np.sqrt(len(can_dims)))
        else:
            results["canonical"]["dims"].append(np.nan)
            results["canonical"]["sems"].append(np.nan)

        # GUE ensemble
        gue_dims = []
        for seed in range(n_samples):
            try:
                ops = models.random_hamiltonian_ensemble(d, k, "GUE", seed=seed)
                result = compute_lie_algebra_dimension(ops, max_depth=4, max_dim=max_dim)
                gue_dims.append(result["dimension"])
            except Exception as e:
                pass

        if gue_dims:
            results["gue"]["dims"].append(np.mean(gue_dims))
            results["gue"]["sems"].append(np.std(gue_dims) / np.sqrt(len(gue_dims)))
        else:
            results["gue"]["dims"].append(np.nan)
            results["gue"]["sems"].append(np.nan)

        can_str = f"{np.mean(can_dims):.1f}" if can_dims else "N/A"
        gue_str = f"{np.mean(gue_dims):.1f}" if gue_dims else "N/A"
        print(f"  Canonical: dim={can_str}/{max_dim}")
        print(f"  GUE:       dim={gue_str}/{max_dim}")

    return results


def analyze_geo2_algebra(nx: int, ny: int, k_values: List[int]) -> Dict:
    """
    Analyze Lie algebra for GEO2 ensemble.

    Args:
        nx, ny: Lattice dimensions
        k_values: List of K values to test

    Returns:
        Dictionary with algebra dimensions
    """
    d = 2 ** (nx * ny)
    max_dim = d ** 2 - 1

    # Create GEO2 basis
    geo2 = models.GeometricTwoLocal(nx, ny)
    L = geo2.L

    results = {
        "nx": nx,
        "ny": ny,
        "d": d,
        "L": L,
        "max_dim": max_dim,
        "k_values": [],
        "dims": [],
    }

    print(f"\n{'='*60}")
    print(f"GEO2 Lie Algebra Analysis: {nx}x{ny} lattice, d={d}, L={L}")
    print(f"{'='*60}")

    for k in k_values:
        if k > L:
            print(f"  K={k} > L={L}, skipping")
            continue

        results["k_values"].append(k)

        # Sample K operators from GEO2 basis
        rng = np.random.RandomState(42)
        indices = rng.choice(L, size=k, replace=False)
        ops = [geo2.Hs[i] for i in indices]

        result = compute_lie_algebra_dimension(ops, max_depth=4, max_dim=max_dim, verbose=False)
        results["dims"].append(result["dimension"])

        print(f"  K={k}: dim={result['dimension']}/{max_dim} ({100*result['dimension']/max_dim:.1f}%)")

    return results


# =============================================================================
# VISUALIZATION
# =============================================================================

def plot_algebra_comparison(canonical_results: Dict, geo2_results: Dict, output_dir: Path):
    """Plot Lie algebra dimension comparison."""
    output_dir.mkdir(parents=True, exist_ok=True)

    fig, axes = plt.subplots(1, 2, figsize=(12, 5))

    d = canonical_results["d"]
    max_dim = d ** 2 - 1

    # Left: Canonical vs GUE
    ax = axes[0]
    k_vals = np.array(canonical_results["k_values"])
    can_dims = np.array(canonical_results["canonical"]["dims"])
    gue_dims = np.array(canonical_results["gue"]["dims"])

    ax.plot(k_vals, can_dims / max_dim * 100, 'o-', label='Canonical', markersize=8)
    ax.plot(k_vals, gue_dims / max_dim * 100, 's--', label='GUE', markersize=8)
    ax.axhline(100, color='gray', linestyle=':', label=f'su({d}) = {max_dim}')

    ax.set_xlabel('K (number of operators)')
    ax.set_ylabel('Lie algebra dimension (% of su(d))')
    ax.set_title(f'Canonical vs GUE (d={d})')
    ax.legend()
    ax.grid(True, alpha=0.3)

    # Right: GEO2
    ax = axes[1]
    if geo2_results["dims"]:
        geo2_max = geo2_results["d"] ** 2 - 1
        k_vals = np.array(geo2_results["k_values"])
        geo2_dims = np.array(geo2_results["dims"])

        ax.plot(k_vals, geo2_dims / geo2_max * 100, 'o-', label='GEO2', markersize=8, color='C2')
        ax.axhline(100, color='gray', linestyle=':', label=f'su({geo2_results["d"]}) = {geo2_max}')
        ax.axvline(geo2_results["L"], color='red', linestyle='--', label=f'L={geo2_results["L"]}')

        ax.set_xlabel('K (number of operators)')
        ax.set_ylabel('Lie algebra dimension (% of su(d))')
        ax.set_title(f'GEO2 ({geo2_results["nx"]}x{geo2_results["ny"]} lattice, d={geo2_results["d"]})')
        ax.legend()
        ax.grid(True, alpha=0.3)

    fig.suptitle('Lie Algebra Dimension vs Number of Operators', fontsize=14, fontweight='bold')
    plt.tight_layout()

    output_file = output_dir / "lie_algebra_comparison.png"
    plt.savefig(output_file, dpi=200, bbox_inches='tight')
    plt.close()
    print(f"\n✓ Saved: {output_file}")


# =============================================================================
# MAIN
# =============================================================================

if __name__ == "__main__":
    # Analyze for d=8 (faster for testing)
    d = 8
    k_values = [2, 4, 6, 8, 10, 12]

    print("=" * 70)
    print("LIE ALGEBRA ANALYSIS")
    print("=" * 70)

    # Canonical and GUE comparison
    canonical_results = analyze_ensemble_algebras(d, k_values, n_samples=5)

    # GEO2 analysis (3 qubits = d=8 is 1×3 chain or similar)
    geo2_results = analyze_geo2_algebra(1, 3, k_values=[2, 4, 6, 8, 10])

    # Save results
    output_dir = Path(__file__).parent.parent.parent / "data" / "raw_logs"
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_file = output_dir / f"lie_algebra_analysis_{timestamp}.pkl"

    results = {
        "canonical_gue": canonical_results,
        "geo2": geo2_results,
        "timestamp": datetime.now().isoformat()
    }

    with open(output_file, 'wb') as f:
        pickle.dump(results, f)
    print(f"\n✓ Saved results: {output_file}")

    # Generate plots
    fig_dir = Path(__file__).parent.parent.parent / "fig" / "integrability"
    plot_algebra_comparison(canonical_results, geo2_results, fig_dir)

    print("\n" + "=" * 70)
    print("ANALYSIS COMPLETE")
    print("=" * 70)
