# Next Experiments: Floquet-Enhanced Reachability Criteria

**Date:** January 8, 2026
**Based on:** Floquet vs Static moment criterion results (scaling_floquet_o2_20260108_040340)

---

## Overview

Following the successful demonstration that Floquet-Magnus engineering strengthens the moment criterion (λ ratio = 1.07, K=3 improvement = +217%), we propose four follow-up experiments to:

1. Test on **physically relevant targets** (quantum error correction codes)
2. **Scale to larger systems** (d = 16, 32, 64)
3. **Optimize driving functions** for maximum discriminative power
4. **Extend to third-order Magnus** expansion

**Priority order:**
1. **5-Qubit Perfect Code** (highest impact, physically motivated)
2. System size scaling (tests generality)
3. Driving optimization (engineering improvement)
4. Third-order Magnus (theoretical extension)

---

## Experiment A: 5-Qubit Perfect Code Preparation

### A.1 Motivation

**Question:** Can Floquet criterion detect unreachability of QEC code states with fewer operators than static criterion?

**Physical relevance:**
- Preparing logical states of quantum error correction codes is a fundamental task
- The [[5,1,3]] code is the smallest code that corrects arbitrary single-qubit errors
- Testing criterion on structured targets (vs random Haar) is more realistic

**Connection to paper:** The paper mentions classifying QEC codes by "Magnus order required for preparation" — this experiment directly tests that concept.

### A.2 System Setup

**5-qubit perfect code** (Laflamme-Knill code, [[5,1,3]]):
- Encodes 1 logical qubit into 5 physical qubits
- Distance d=3 (corrects 1 arbitrary error)
- Stabilizer group generated by 4 operators

**Stabilizer generators:**
```
S_1 = XZZXI
S_2 = IXZZX
S_3 = XIXZZ
S_4 = ZXIXZ
```

**Logical states:**

$|0_L\rangle$ has 16 basis states with specific signs (see below).

$|1_L\rangle = X_L |0_L\rangle$ where $X_L = XXXXX$.

### A.3 Mathematical Setup

**Initial state:** $|\psi\rangle = |00000\rangle$

**Target state:** $|\phi\rangle = |0_L\rangle$ of 5-qubit perfect code

**Explicit construction of $|0_L\rangle$:**
```python
def create_5qubit_code_logical_zero():
    """
    Create |0_L⟩ of the 5-qubit perfect code.

    The logical zero state is:
    |0_L⟩ = (1/4) * sum of 16 basis states with specific signs

    Basis states grouped by weight:
    Weight 0: +|00000⟩
    Weight 2: +|10010⟩, +|01001⟩, +|10100⟩, +|01010⟩
    Weight 3: -|11011⟩, -|00110⟩, -|11000⟩, -|11101⟩,
              -|00011⟩, -|11110⟩, -|01111⟩, -|10001⟩,
              -|01100⟩, -|10111⟩
    Weight 4: +|00101⟩
    """
    d = 32  # 2^5
    psi = np.zeros(d, dtype=complex)

    # Weight 0
    psi[0b00000] = +1

    # Weight 2 (4 states)
    psi[0b10010] = +1
    psi[0b01001] = +1
    psi[0b10100] = +1
    psi[0b01010] = +1

    # Weight 3 (10 states)
    psi[0b11011] = -1
    psi[0b00110] = -1
    psi[0b11000] = -1
    psi[0b11101] = -1
    psi[0b00011] = -1
    psi[0b11110] = -1
    psi[0b01111] = -1
    psi[0b10001] = -1
    psi[0b01100] = -1
    psi[0b10111] = -1

    # Weight 4 (1 state)
    psi[0b00101] = +1

    # Normalize
    psi /= np.linalg.norm(psi)

    return psi
```

**Verification:**
```python
def verify_5qubit_code_logical_zero(psi):
    """Verify that psi is in the +1 eigenspace of all stabilizers."""
    # Define stabilizers as 32x32 matrices
    S1 = tensor_product([X, Z, Z, X, I])  # XZZXI
    S2 = tensor_product([I, X, Z, Z, X])  # IXZZX
    S3 = tensor_product([X, I, X, Z, Z])  # XIXZZ
    S4 = tensor_product([Z, X, I, X, Z])  # ZXIXZ

    stabilizers = [S1, S2, S3, S4]

    for i, S in enumerate(stabilizers):
        eigenvalue = np.dot(psi.conj(), S @ psi).real
        print(f"S{i+1} eigenvalue: {eigenvalue:.6f} (should be +1)")
        assert abs(eigenvalue - 1.0) < 1e-10, f"S{i+1} eigenvalue is {eigenvalue}, not +1"

    print("✓ All stabilizers have +1 eigenvalue")
    return True
```

### A.4 Hamiltonian Ensembles to Test

**Option 1: GEO2LOCAL (5 qubits, 1D chain)**
- 5 qubits on a line: 1-2-3-4-5
- Nearest-neighbor 2-body terms: $(1,2), (2,3), (3,4), (4,5)$
- Total operators: $L = 3n + 9|E| = 15 + 36 = 51$
- Test K = 2, 4, 6, 8, 10, 12, ..., 30

**Option 2: All 2-body operators**
- All $\binom{5}{2} = 10$ pairs
- 3 Pauli types per pair: XX, YY, ZZ (or XY, XZ, YZ depending on model)
- Total: $3 \times 10 = 30$ operators
- Simpler, but less structured

**Option 3: Stabilizer-aware subset**
- Include all stabilizer generators and their conjugates
- Test if criterion can detect when operators CANNOT generate $|0_L\rangle$

### A.5 Experimental Questions

**Q1:** What is $K_c$ such that:
- Static criterion: Can prove unreachable for $K < K_{c,\text{static}}$
- Floquet criterion: Can prove unreachable for $K < K_{c,\text{floquet}}$

**Expected:** $K_{c,\text{floquet}} > K_{c,\text{static}}$ (Floquet detects unreachability with MORE operators)

**Q2:** Is there a Magnus order threshold?
- Can $|0_L\rangle$ be prepared with 1st-order Floquet (time-averaged)?
- Does it require 2nd-order (commutators)?
- Or even 3rd-order (nested commutators)?

**Q3:** How does criterion strength vary with code structure?
- Compare: Random Haar vs $|0_L\rangle$ vs GHZ state vs W state
- Which are "easier" to detect as unreachable?

### A.6 Implementation

```python
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent))

import numpy as np
from reach import floquet, models, moment_criteria

def create_5qubit_code_logical_zero():
    """Create |0_L⟩ of 5-qubit perfect code."""
    d = 32
    psi = np.zeros(d, dtype=complex)

    # [Implementation from A.3 above]

    return psi

def run_5qubit_code_experiment():
    """
    Test static vs Floquet criteria on |00000⟩ → |0_L⟩ preparation.
    """
    print("="*70)
    print("5-QUBIT PERFECT CODE REACHABILITY EXPERIMENT")
    print("="*70)

    # Setup
    n_qubits = 5
    d = 32

    # States
    psi = np.zeros(d, dtype=complex)
    psi[0] = 1.0  # |00000⟩

    phi = create_5qubit_code_logical_zero()

    # Verify code state
    print("\nVerifying |0_L⟩ construction...")
    # [Stabilizer verification code]

    # Generate Hamiltonians (1D chain)
    print("\nGenerating GEO2LOCAL Hamiltonians (1D chain)...")
    hams_qutip = models.random_hamiltonian_ensemble(
        dim=d, k=51, ensemble="GEO2", nx=5, ny=1, seed=42
    )
    hams = floquet.hamiltonians_to_numpy(hams_qutip)

    # Test range
    K_values = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30]

    print("\n" + "="*70)
    print("TESTING CRITERIA AT VARIOUS K")
    print("="*70)
    print("\n  K | Static | Floquet | Comment")
    print("-----|--------|---------|" + "-"*40)

    K_c_static = None
    K_c_floquet = None

    for K in K_values:
        # Static criterion
        unreachable_static, _, _ = moment_criteria.static_moment_criterion(
            psi, phi, hams[:K]
        )

        # Floquet criterion (search 100 random λ)
        unreachable_floquet, _, _, _ = moment_criteria.floquet_moment_criterion_optimized(
            psi, phi, hams[:K],
            driving_functions=lambda k: (np.sin, np.cos)[k % 2],  # Bichromatic
            period=2*np.pi,
            order=2,
            n_lambda_trials=100
        )

        # Determine critical K
        if unreachable_static and K_c_static is None:
            K_c_static = K

        if unreachable_floquet and K_c_floquet is None:
            K_c_floquet = K

        # Format output
        static_str = "✓ UNREACH" if unreachable_static else "✗ inconc"
        floquet_str = "✓ UNREACH" if unreachable_floquet else "✗ inconc"

        # Comment
        if unreachable_floquet and not unreachable_static:
            comment = "← Floquet succeeds, static fails!"
        elif unreachable_static and unreachable_floquet:
            comment = "Both succeed"
        else:
            comment = ""

        print(f" {K:3d} | {static_str:10s} | {floquet_str:11s} | {comment}")

    print("\n" + "="*70)
    print("CRITICAL K VALUES")
    print("="*70)

    if K_c_static:
        print(f"\nStatic criterion:  K_c = {K_c_static}")
        print(f"  → Proves unreachable with {K_c_static} operators or fewer")
    else:
        print("\nStatic criterion:  K_c = None (never proved unreachable)")

    if K_c_floquet:
        print(f"\nFloquet criterion: K_c = {K_c_floquet}")
        print(f"  → Proves unreachable with {K_c_floquet} operators or fewer")
    else:
        print("\nFloquet criterion: K_c = None (never proved unreachable)")

    if K_c_static and K_c_floquet:
        improvement = K_c_floquet - K_c_static
        print(f"\n✓ Floquet advantage: Can prove unreachable with {improvement} MORE operators")

    print("\n" + "="*70)
    print("INTERPRETATION")
    print("="*70)

    print("\nIf K_c exists:")
    print("  → |0_L⟩ is provably UNREACHABLE with fewer than K_c operators")
    print("  → This provides a lower bound on resources needed for code preparation")
    print("\nIf K_c_floquet > K_c_static:")
    print("  → Floquet criterion is STRONGER (detects unreachability at higher K)")
    print("  → Time-dependent control makes criterion more discriminative")

    return {
        'K_values': K_values,
        'K_c_static': K_c_static,
        'K_c_floquet': K_c_floquet
    }

if __name__ == '__main__':
    results = run_5qubit_code_experiment()

    # Save results
    import pickle
    with open('results/5qubit_code_experiment.pkl', 'wb') as f:
        pickle.dump(results, f)

    print("\n✓ Results saved to results/5qubit_code_experiment.pkl")
```

### A.7 Expected Outcomes

**Scenario 1: Floquet finds higher K_c**
- Static: $K_c = 6$ (can prove unreachable with K ≤ 6)
- Floquet: $K_c = 10$ (can prove unreachable with K ≤ 10)
- **Conclusion:** Floquet criterion is stronger, confirms Haar state results

**Scenario 2: Both criteria fail**
- Neither criterion proves unreachable at any K
- **Conclusion:** $|0_L\rangle$ may be too "generic" (high entanglement like Haar)

**Scenario 3: Floquet succeeds, static fails completely**
- Static: No K where criterion succeeds
- Floquet: $K_c = 8$
- **Conclusion:** Commutator terms are ESSENTIAL for this target

### A.8 Extensions

**Compare multiple code states:**
- $|0_L\rangle$ vs $|1_L\rangle$ vs $|+_L\rangle = (|0_L\rangle + |1_L\rangle)/\sqrt{2}$
- Test if certain logical states are "easier" to prepare

**Compare different codes:**
- [[5,1,3]] (5-qubit perfect)
- [[7,1,3]] (Steane code)
- [[9,1,3]] (Shor code)
- **Question:** Does code distance correlate with K_c?

**Test stabilizer-based Hamiltonians:**
- Restrict operators to stabilizer generators and their products
- More physical for QEC implementations

### A.9 Computational Cost

**Per K test:**
- Static: ~1-2 seconds (32×32 eigendecomposition)
- Floquet: ~100-200 seconds (100 λ searches)

**Total runtime:**
- 15 K values × 200 sec/K ≈ **50 minutes per criterion**
- Total: **~1.5-2 hours** for complete experiment

Much faster than the 11-hour Haar state experiment!

---

## Experiment B: System Size Scaling

### B.1 Motivation

Test whether the Floquet advantage ($\lambda_{\text{floquet}}/\lambda_{\text{static}}$) **increases with system size**.

**Hypothesis:** Larger systems → more commutators → stronger Floquet advantage

### B.2 Setup

**System sizes:**
- n=4 qubits, d=16 (current, baseline)
- n=5 qubits, d=32
- n=6 qubits, d=64

**Hamiltonian ensemble:** GEO2LOCAL (2D lattices)
- 4 qubits: 2×2 lattice
- 5 qubits: Not a perfect square — use 1×5 chain or skip
- 6 qubits: 2×3 lattice or 3×2 lattice

**Test:** Random Haar state pairs, measure $P(K | d)$ and fit exponential.

### B.3 Expected Scaling

**Theoretical prediction:**

If commutators provide advantage proportional to system size:
$$\frac{\lambda_{\text{floquet}}(d)}{\lambda_{\text{static}}(d)} \sim 1 + c \cdot \log(d)$$

**Test:**
- d=16: ratio = 1.07 (measured)
- d=32: ratio = 1.10-1.15 (predicted)
- d=64: ratio = 1.15-1.25 (predicted)

**If ratio is constant:** Floquet advantage is intrinsic, not system-size dependent.

### B.4 Implementation

Reuse `scripts/run_scaling_experiment.py` with:
- `--n-qubits 4 5 6`
- `--ensemble GEO2`
- `--criterion static` and `--criterion floquet_o2`

Runtime: ~30-40 hours for full sweep (d=16,32,64 × static+Floquet × 100 trials × 100 λ)

### B.5 Analysis

Plot $\lambda(d)$ for both criteria:
- If both scale similarly → no size advantage
- If Floquet scales faster → advantage grows with system size

---

## Experiment C: Driving Function Optimization

### C.1 Motivation

Current experiment uses **fixed bichromatic driving**. Can we do better?

**Question:** What driving functions $f_k(t)$ maximize the Floquet criterion's discriminative power?

### C.2 Driving Types to Compare

**1. Constant (baseline):**
$$f_k(t) = 1 \quad \Rightarrow \quad H_F^{(2)} = 0$$

No advantage over static criterion.

**2. Sinusoidal with offset:**
$$f_k(t) = A + B \sin(\omega_k t)$$

Tune A, B to maximize $\|H_F^{(2)}\|$.

**3. Bichromatic (current):**
$$f_k(t) = \sin(\omega_k t), \quad \omega_k \in \\{\omega_1, \omega_2\\}$$

**4. Multichromatic:**
$$f_k(t) = \sum_{j=1}^M c_{kj} \sin(\omega_j t + \phi_{kj})$$

Optimize $(c_{kj}, \phi_{kj})$ for maximum $\|H_F^{(2)}\|$.

**5. Square wave:**
$$f_k(t) = \text{sign}(\sin(\omega_k t))$$

Bang-bang control (experimentally common).

**6. Optimized (numerical):**
Parameterize $f_k(t)$ as Fourier series, optimize coefficients to maximize:
$$\max_{\{f_k\}} \mathbb{E}_{(\psi,\phi)} \left[ P(\text{unreachable} | f_k) \right]$$

### C.3 Optimization Target

**Objective:** Maximize $\|H_F^{(2)}\|$ for given Hamiltonians.

$$H_F^{(2)} = \frac{1}{2iT} \sum_{j,k} \lambda_j \lambda_k F_{jk} [H_j, H_k]$$

$$\|H_F^{(2)}\|_F^2 = \sum_{j<k} |\lambda_j \lambda_k F_{jk}|^2 \| [H_j, H_k] \|_F^2$$

To maximize, want $|F_{jk}|$ large for pairs with large $\|[H_j, H_k]\|$.

**Heuristic:** Make driving functions "as different as possible" (low cross-correlation).

### C.4 Implementation

```python
def optimize_driving_functions(hamiltonians, T=2*np.pi, n_freq=3):
    """
    Optimize driving functions to maximize ||H_F^(2)||.

    Parameterization: f_k(t) = sum_j c_kj sin(omega_j t + phi_kj)

    Returns: optimal (c, phi) coefficients
    """
    K = len(hamiltonians)

    # Objective: maximize ||H_F^(2)||
    def objective(params):
        c = params[:K*n_freq].reshape(K, n_freq)
        phi = params[K*n_freq:].reshape(K, n_freq)

        # Compute F_jk integrals
        F = np.zeros((K, K))
        for j in range(K):
            for k in range(K):
                # Numerical integration of f_j(t) f_k(t)
                integrand = lambda t: sum(c[j,m] * np.sin(m*t + phi[j,m]) for m in range(n_freq)) * \
                                       sum(c[k,m] * np.sin(m*t + phi[k,m]) for m in range(n_freq))
                F[j,k], _ = quad(integrand, 0, T)
                F[j,k] /= T

        # Compute ||H_F^(2)||
        H_F2_norm = 0
        for j in range(K):
            for k in range(j+1, K):
                comm = commutator(hamiltonians[j], hamiltonians[k])
                H_F2_norm += abs(F[j,k])**2 * np.linalg.norm(comm, 'fro')**2

        return -H_F2_norm  # Minimize negative = maximize norm

    # Initialize with random
    x0 = np.random.randn(2*K*n_freq) * 0.1

    # Optimize
    from scipy.optimize import minimize
    result = minimize(objective, x0, method='L-BFGS-B')

    c_opt = result.x[:K*n_freq].reshape(K, n_freq)
    phi_opt = result.x[K*n_freq:].reshape(K, n_freq)

    return c_opt, phi_opt
```

### C.5 Expected Improvements

**Current (bichromatic):** λ ratio = 1.07

**Optimized driving:** λ ratio = 1.15-1.30 (predicted)

**Best case:** Approach Spectral criterion (λ ≈ 0.07, ratio ~25×)

Unlikely to reach Spectral performance (that requires full λ optimization, not just driving), but should exceed bichromatic.

---

## Experiment D: Third-Order Magnus Expansion

### D.1 Motivation

Second-order Magnus generates **3-body operators** from 2-body inputs via commutators.

Third-order generates **4-body operators** via nested commutators:
$$H_F^{(3)} \propto [[H_j, H_k], H_m]$$

**Expected:** Even stronger criterion, especially for systems with few-body interactions.

### D.2 Mathematical Formulation

$$H_F^{(3)} = \frac{1}{6T} \int_0^T dt_1 \int_0^{t_1} dt_2 \int_0^{t_2} dt_3 \, \Big( [[H(t_1), H(t_2)], H(t_3)] + [H(t_3), [H(t_2), H(t_1)]] \Big)$$

For time-periodic $H(t) = \sum_k \lambda_k f_k(t) H_k$:

$$H_F^{(3)} = \sum_{j,k,m} \lambda_j \lambda_k \lambda_m G_{jkm} [[H_j, H_k], H_m]$$

where $G_{jkm}$ are triple integrals of driving functions.

### D.3 Implementation Challenge

**Computational cost:**
- Second-order: $O(K^2)$ commutators
- Third-order: $O(K^3)$ nested commutators

For K=20, this is 8000 nested commutator evaluations per λ trial!

**Strategy:** Precompute and cache all $[[H_j, H_k], H_m]$ operators.

### D.4 Expected Scaling

**Hypothesis:** $\lambda_{\text{floquet-O3}} > \lambda_{\text{floquet-O2}} > \lambda_{\text{static}}$

**Predicted ratio:**
- O(2): 1.07 (measured)
- O(3): 1.15-1.40 (predicted)

### D.5 Implementation Outline

```python
def floquet_moment_criterion_O3(psi, phi, hamiltonians, lambdas,
                                 driving_functions, period, n_lambda_trials=100):
    """
    Floquet moment criterion using third-order Magnus expansion.
    """
    K = len(hamiltonians)

    # Precompute all nested commutators
    print("Precomputing nested commutators...")
    nested_comms = {}
    for j in range(K):
        for k in range(K):
            for m in range(K):
                comm_jk = commutator(hamiltonians[j], hamiltonians[k])
                nested_comms[(j,k,m)] = commutator(comm_jk, hamiltonians[m])

    # [Rest of implementation similar to O(2) but using H_F^(3) derivatives]
```

---

## Summary of Recommended Experiments

| Experiment | Duration | Impact | Priority |
|------------|----------|--------|----------|
| **A. 5-Qubit Perfect Code** | ~2 hours | High (physical relevance) | **1** |
| **B. System Size Scaling** | ~30-40 hours | Medium (tests generality) | 2 |
| **C. Driving Optimization** | ~5-10 hours | Medium (engineering improvement) | 3 |
| **D. Third-Order Magnus** | ~15-20 hours | Low (theoretical extension) | 4 |

**Recommended next step:** Implement and run **Experiment A** (5-qubit perfect code).

---

## File Structure for Implementation

```
scripts/
├── run_5qubit_code_experiment.py    # Experiment A
├── run_system_size_scaling.py       # Experiment B
├── optimize_driving_functions.py     # Experiment C
├── test_third_order_magnus.py        # Experiment D

reach/
├── qec_codes.py                      # QEC code state generators
├── moment_criteria.py                # (extend with O(3) support)
├── floquet.py                        # (add driving optimization)

results/
├── 5qubit_code_experiment.pkl
├── system_size_scaling.pkl
├── driving_optimization.pkl
├── third_order_magnus.pkl

plots/
├── 5qubit_code_K_thresholds.png
├── system_size_lambda_scaling.png
├── driving_comparison.png
├── magnus_order_comparison.png
```

---

**Last updated:** 2026-01-08
